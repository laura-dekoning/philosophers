diff --git a/philo/Makefile b/philo/Makefile
index 291da75..ff7f66e 100644
--- a/philo/Makefile
+++ b/philo/Makefile
@@ -6,7 +6,7 @@
 
@@ -26,6 +26,7 @@ SRC_DIR			:=	src
 SRC_FILES		:=	main.c \
 					parser.c \
 					init.c \
+					mutexes.c \
 					dinner.c \
 					dinner_utils.c \
 					utils.c \
diff --git a/philo/incl/philo.h b/philo/incl/philo.h
index bccd79f..4fc61e3 100644
--- a/philo/incl/philo.h
+++ b/philo/incl/philo.h
@@ -6,7 +6,7 @@
 
@@ -91,6 +91,8 @@ void	precise_usleep(size_t usec, t_table *table);
 
 // MUTEX
 int		mutex_handle(pthread_mutex_t *mutex, t_opcode opcode);
+int		init_forks(t_table *table);
+
 
 // SYNCHRO UTILS
 void	wait_all_threads(t_table *table);
diff --git a/philo/incl/structs.h b/philo/incl/structs.h
index c83e678..a319064 100644
--- a/philo/incl/structs.h
+++ b/philo/incl/structs.h
@@ -6,7 +6,7 @@
 
@@ -73,12 +73,13 @@ typedef struct s_table
 	pthread_t		*philo_threads; // a philo is a thread, this is the id
 	pthread_t		*monitor_thread;
 	pthread_mutex_t	*forks; //array of forks
+	pthread_mutex_t	*prog_m; //array of program mutexes
 	pthread_mutex_t	table_mutex; //avoid races while reading from table
 	pthread_mutex_t	write_mutex;
 	pthread_mutex_t	time_mutex; //useful for races with the monitor
 }					t_table;
 
-typedef enum s_opcode
+typedef enum e_opcode
 {
 	LOCK,
 	UNLOCK,
@@ -88,7 +89,7 @@ typedef enum s_opcode
 	DESTROY
 }	t_opcode;
 
-typedef enum s_philo_status
+typedef enum e_philo_status
 {
 	EATING,
 	SLEEPING,
@@ -98,4 +99,12 @@ typedef enum s_philo_status
 	DEAD
 }	t_philo_status;
 
+typedef enum e_prog
+{
+	START,
+	STOP,
+	DISPLAY,
+	ALL
+}	t_prog;
+
 #endif
\ No newline at end of file
diff --git a/philo/src/init.c b/philo/src/init.c
index c4428d1..cf61ec1 100644
--- a/philo/src/init.c
+++ b/philo/src/init.c
@@ -6,30 +6,12 @@
 
 #include "philo.h"
 
-int	init_forks(t_table *table)
-{
-	size_t	i;
-
-	table->forks = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t)
-			* table->philo_count);
-	if (!table->forks)
-		return (ft_error(table, MALLOC));
-	i = 0;
-	while (i < table->philo_count)
-	{
-		if (pthread_mutex_init(&table->forks[i], NULL) != SUCCESS)
-			return (ft_error(table, MUTEX_INIT));
-		i++;
-	}
-	return (SUCCESS);
-}
-
 /**
  * Every philosopher starts with his own fork on the right side.
  * So philo[0] (philo 1) has fork[0] on the right and fork[philo_count]
@@ -123,5 +105,6 @@ int	init_table(t_table *table)
 			retval--;
 		}
 	}
+	//CHECK IF THIS IS NECESSARY
 	return (SUCCESS);
 }
diff --git a/philo/src/utils.c b/philo/src/utils.c
index 26c3ea6..7c84d11 100644
--- a/philo/src/utils.c
+++ b/philo/src/utils.c
@@ -6,7 +6,7 @@
 
@@ -88,3 +88,20 @@ void	write_status(t_philo_status status, t_philo *philo)
 		printf("%-6ld%d %s\n", time, id, DIED);
 	pthread_mutex_unlock(&philo->table->write_mutex);
 }
+
+//Check if this is correct, maybe something else needs to happen if simulation is finished.
+//But maybe just unlock and NOT print is fine. 
+// void	write_status(char *status, t_philo *philo)
+// {
+// 	size_t	elapsed;
+// 	size_t	time;
+// 	int		id;
+
+// 	elapsed = gettime();
+// 	time = elapsed - philo->table->start_simulation;
+// 	id = philo->philo_id;
+// 	mutex_handle(&philo->table->prog_m[DISPLAY], LOCK);
+// 	if (!simulation_finished(philo->table))
+// 		printf("%-6ld%d %s\n", time, id, status);
+// 	mutex_handle(&philo->table->prog_m[DISPLAY], UNLOCK);
+// }
